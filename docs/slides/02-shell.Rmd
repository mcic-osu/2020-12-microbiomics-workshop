---
title: "An Introduction to the shell"
author: "Jelmer Poelstra"
institute: "MCIC Wooster"
date: "2020/12/16 (updated: `r Sys.Date()`)"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---
class:inverse middle center

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
```
# Overview

.pull-left[
### [Introduction](#intro)
### [First Command: `cal`](#cal)
### [Navigation](#navigation)
### [Managing Files](#managing_files)
]

---
class:inverse middle center
name: overview

# Overview

.pull-left[
### [Introduction](#intro)
### [First Command: `cal`](#cal)
### [Navigation](#navigation)
### [Managing Files](#managing_files)
]

.pull-right[
### [Working with Text Files](#text_files)
### [Keyboard Shortcuts and Tricks](#tricks)
### [A Very Minimal Script](#script)
]



---
class:inverse middle center
name:intro

# Introduction

-----

<br><br><br><br>

### [[Back to overview]](#overview)

---

## What is a shell?

- The shell is a **command-line interface (CLI) to the
  operating system**.

- At least, for Unix-like operating systems,
  such as Linux and Mac.   
  (In Windows, there isn't really a shell, but there are [ways to   get one](#windows-shell)).

--

<br>

### Shell flavors

- Many shell variants exist but are very similar.

- We will be using the **bash shell**.   
  
  This is most common shell, and the default in Mac and Linux,
  including at OSC (which runs Linux).

---

## But what can I do in the shell?

--

**The shell:**

- Provides a powerful way to **manage and manipulate files**.

--

- Is the most efficient (or only) way to **run many programs
  and submit scripts** -- especially when dealing with bioinformatic data.

--

- Is the most efficient (or only) way to **interact with remote
  computers** such as the OSC clusters.

--

- Makes it easy to **keep *exact* track of what you've done**.

---

## Let's open up a shell at OSC!

- The Ohio Supercomputer Center (OSC) allows us to use a shell   
  *within* a browser at <https://ondemand.osc.edu/>.

<br>

<p align = "center">
<img src=figs_shell/OSC_shell.png width="900">
</p>

<br>

- In the "`Clusters`" dropdown menu, click "`Pitzer Shell Access`".


---

## The shell prompt

- OSC show us lots of welcome messages and information:

<p align="left">
<img src=figs_shell/OSC_welcome.png width="550">
</p>

<p align="center">
<img src=figs_shell/OSC_welcome2.png width="1000">
</p>

--

- And a **prompt** -- this is where we type.

<p align="center">
<img src=figs_shell/OSC_prompt.png width="900">
</p>

---
class: center middle

# In the shell, <br> we're mostly typing commands

--

### Basic usage is just memorizing commands for common utilities

---
class:inverse middle center
name:cal

# Our first command:
# `cal`

----

<br><br><br><br>

### [[Back to overview]](#overview)


---

## A trivial example: the "`cal`" command

- Just typing `cal` prints a calendar to screen:

  ```sh
  $ cal      # I'm using a $ to indicate the prompt
  ```

--

<p align="left">
<img src=figs_shell/cal.png width="400">
</p>

---

## A trivial example: the "`cal`" command

- Just typing `cal` prints a calendar to screen:

  ```sh
  $ cal      # I'm using a $ to indicate the prompt
  ```

- We can use the "-j" or "-m" **options** (flags):
  ```sh
  $ cal -j    # Show a Julian calendar
  $ cal -m    # Have weeks start on Monday
  ```

--

- We can use a year as an **argument** (parameter):
  
  ```sh
  $ cal 2020  # Print the calendar for 2020
  ```

--

- We can combine options and arguments, e.g.:

  ```sh
  $ cal -j -m 2020
  
  $ cal -jm 2020     # Shorter notation!
  ```

---
class: middle center

# `cal` 
-----

# THE DEMO


---

## What we've learned from `cal`

- We can use **options (flags) and arguments (parameters)** <br> to
  modify or determine what a command does.

- These arguments and options are **separated by spaces**.

--

<br>

### What if my argument, e.g. a file name, has a space in it?

--

- Quote it! (And avoid spaces in file names.)

  ```sh
  $ echo "Hello World"
  # Hello World

  $ mv "My bad file name.docx" "My_better_file_name.docx"
  ```

--

<br>

- Note that everything after a "`#`" is ignored -- useful for comments!

---

## How can we know a command's options?

Many commands have a "`--help`" option:

```sh
cal --help
# Usage:
#  cal [options] [[[day] month] year]

# Options:
#  -1, --one        show only current month (default)
#  -3, --three      show previous, current and next month
#  -s, --sunday     Sunday as first day of week
#  -m, --monday     Monday as first day of week
#  -j, --julian     output Julian dates
#  -y, --year       show whole current year
#  -V, --version    display version information and exit
#  -h, --help       display this help text and exit
```

---

## How can we know a command's options? (cont.)

- Using the `man` ("manual") command,   
  whose argument is the command or utility we want the manual for:

```sh
$ man ls
```
<p align="center">
<img src=figs_shell/man_ls.png width="600">
</p>


---
class: center middle

# Let's learn some useful commands, maybe

<br><br>




---
class: center middle inverse
name:navigation

# Navigation

----

<br><br><br><br>

### [[Back to overview]](#overview)

---

## Navigation: overview

```sh
$ pwd   # Provide Working Directory (where am I?)

$ ls    # List files and dirs in your current working directory

$ cd    # Change working directory
```

--

<br>

- Which of these commands might need an *argument*?

--

```sh
$ cd <destination-dir>
```

---

## Navigation I: **`pwd`** (Provide Working Directory)

```sh
$ pwd
# /users/PAS0471/jelmer/CSB
```

--

<br>

- Notice that directories are separated by **forward slashes "`/`"** <br> in Unix environments.

<br>

- When moving files around, it is useful to know the following shortcut
  for the current working directory:

  ```sh
  .
  ```


---

## Navigation II: `ls` (LiSt)

```sh
$ ls

# data_wrangling git good_code LICENSE README.md
```

--

<br>

- We can try some options to modify the output:

```sh
$ ls -l -h   # -l: long format / -h: human-readable file sizes

# drwxr-xr-x 7 jelmer PAS0471 4.0K Dec  4 11:23 data_wrangling
# drwxr-xr-x 5 jelmer PAS0471 4.0K Dec  4 11:23 git
# drwxr-xr-x 5 jelmer PAS0471 4.0K Dec  4 11:23 good_code
# -rw-r--r-- 1 jelmer PAS0471  35K Dec  4 11:23 LICENSE
# -rw-r--r-- 1 jelmer PAS0471 2.4K Dec  4 11:23 README.md
```

--

- Again, these options can be "pasted together":

```sh
ls -lha     # We've added the "-a" option to show hidden files
```

---

## Navigation III: cd (Change Directory)

- Using a **relative path** (i.e., not starting from the root dir):
```sh
cd data_wrangling/
```

- Using an **absolute path** (i.e., starting from the root dir):
```sh
cd /users/PAS0471/jelmer/CSB/data_wrangling
```

--

### Tricks!

```sh
cd ..     # Move one directory up
cd ../..  # Move two directories up
cd ~      # Move to your home dir (~ is always /home/<user>/ !)
cd -      # Go back to last visited dir (like "Back" in a browser)

cd .      # What does this do?
```




---
class: center middle inverse
name:managing_files

# Managing Files

----

<br><br><br><br>

### [[Back to overview]](#overview)

---

## Managing files: overview

```sh
$ mkdir <dirname> # Make a new directory
$ cp <from> <to>  # Copy files or dirs
$ mv <from> <to>  # Move files or dirs (also functions as rename!)
$ rm <file>       # Remove a file or directory
```

--

<br>

### Operating on directories:

- For `cp` and `rm`,   
  the "`-r`" option is needed to act on directories
  (and their contents!)

```sh
# Copy "unix/data/" to the current dir (recall the "." shortcut) 
cp -r unix/data . 
  
# Remove "my_dir" and its contents.
# Beware: there is NO THRASH BIN in the shell!
rm -r my_dir/
```


---

## Your turn

1. Go to **XXX**

1. Create a new directory with your name (no spaces!)

1. Copy README.md into the directory

1. Move into your directory

1. Rename README.md to README.txt

1. Remove your namesake directory and all its contents

---
background-color: #ededed

## Solution

```sh
mkdir jelmer_poelstra

cp README.md jelmer_poelstra/ # Trailing slash can be omitted

cd jelmer_poelstra/           # Idem

mv README.md README.txt

cd ..

rm -r jelmer_poelstra         # Non-interactive: "rm -rf"
```

---

## Managing files: Wildcards

|Wildcard | Matches |
|-|-|
| * | Any number of any character, including nothing |
| ? | Any single character 
| [] | One of the "character set" within the brackets   
| [^] | None of the "character set" within the brackets   



---
class: center middle inverse
name:text_files

# Working With Text Files

----

<br><br><br><br>

### [[Back to overview]](#overview)


---

## Text files: Overview

.pull-left[
### `less`
A file "pager".

<br>

### `cat`
Print contents of (a) file(s).   
Short for conCATenate.
]

.pull-right[
### `head` / `tail`
Show the first or last lines of a file.

<br>

### `grep`
Search for contents within files.
]

---

## Text files I: `less`

- `less` does not load entire files into memory,   
  **so you can easily look at enormous files.**

  ```sh
  less myfile.txt
  ```

- Now you'll be inside the pager, and your prompt is gone.

--

<br>

- Leave `less` by pressing "<kbd>q</kbd>"

- Many keyboard shortcuts to navigate:
  - `d` / `u` &nbsp; &nbsp; go down / up half a page
  - `g` / `G` &nbsp; &nbsp; go to the first / last line
  - `/` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then type keyword to search for
  - `n` / `N` &nbsp; &nbsp; go to next/previous search match

--

### Less try it!

---

## Text files II: `cat`

- `cat` will print one or more files to screen.   
  
  ```sh
  cat my_file.txt
  
  cat my_file.txt > new_file.txt    # What did we do here?
  ```

--

<br>

- If you have, say, 10,000 `fasta` files in a directory,
  each representing a gene, and you want to put them all into
  a single `fasta` file:
  
  ```sh
  cat *.fasta > all.fasta # Wow!
  ```
  Here, the **`*`** allowed us to match all files ending in ".fasta".

--

<br>

- "`z`" counterparts of these functions directly show zipped files:

  ```sh
  zcat my_fastq.gz
  ```

---

## Text files II: `head` and `tail`

- `head` / `tail` will simply show the first / last few lines of a file.

```sh
head my_file.txt        # By default, shows the first 6 lines
head -n 1 my_file.txt   # Just show the first line
```

--

```sh
tail my_file.txt       # By default, shows the first 6 lines
tail -n 1 my_file.txt  # Just show the last line
```

- Showing the last line of a 100 GB file outside of the
  shell would be quite an ordeal, while in the shell it's
  extremely simple and lightning fast.

---

## Text files II: `head` and `tail` (cont.)

### More useful options:

- Skip the first line of a file:

  ```sh
  tail -n +2 file
  ```

<br>

- Skip the last line of a file:
  
  ```sh
  head -n -1 file
  ```

--

<br>

- Print line number 1866:
  
  ```sh
  head -n 1866 file | tail -n 1   # We'll talk about the "|" more
  ```

---

## Text files IV: `grep`

---

## Some other commands worth mentioning:

- **`cut`**: cut (select) one or more columns from a tabular file
  
  ```sh
  cut -f 2-5 < my.gff   # Cut the 2nd through 5th column 
  ```

- **`wc` / `wc -l`**: count words or lines (`-l` flag).
  
  ```sh
  wc -l my.fastq   # Count the number of lines in a fastq file.
  ```

- **`sort`**: sort a file by a specified column
  
  ```sh
  sort -k5,5 my.bed
  ```
  
- **`uniq` / `uniq -c`**: retain or count (`-c` flag) unique occurences (*if in order!*)

  ```sh
  uniq ....
  ```

- **Combining these commands to get a sorted list of ... :**
  
  ```sh
  cut -f X my.gff | sort | uniq -c | sort -k2
  ```
  


---
class: center middle inverse
name:redirection

# Redirection and Pipes

----

<br><br><br><br>

### [[Back to overview]](#overview)

---

## Standard out, standard error, and redirection

- The regular output of a command is called "standard out" ("*stdout*").   
  By default, this is printed to screen, but it can be *redirected*
  to a file.

- Output to file -- will create file if it doesn't exist,
```sh
$ grep "Gene001" my.gff > selected_genes.gff
```

- **Append** to file
  ```
  $ grep "Gene002" my.gff >> selected_genes.gff
  ```

---

## Standard input and pipes

- A filename can be given as an argument to most commands.   
  If a filename is provided, this file will be read and
  represent the *input* upon which the command will act:

  ```sh
  grep -v "#" my.vcf
  ```

--

- Most command *also* accept input from "standard input" (*stdin*),   
  using the pipe:

  ```sh
  cat my.vcf | grep -v "#"  # Equivalent to the previous command
  ```
  
  The pipe `|` presents the output (*stdout*) of `cat` as
  input (*stdin*) to `grep`.
  
--

- Some commands *only* accept input from *stdin*.
  When not using these commands in a "pipeline", you can also redirect
  the input:
  ```sh
  cut -f 6 < my.vcf
  
  cut -f 6 < my.vcf > my_column.txt   # Redirect stdin and stdout
  cat my.vcf | cut -f 6 > my_column.txt # A bit more intuitive?
  ```



---
class: center middle inverse
name:tricks

# Keyboard Shortcuts and General Tricks

----

<br><br><br><br>

### [[Back to overview]](#overview)

---

# Keyboard Shortcuts and Tricks I

| Shortcut | Command | Function
|--|--|
| `Tab` | | Tab completion! Files, commands, etc. <br> Double `Tab` to show options when <br> multiple are still available.|
| Up/Down arrow | | Cycle through command history|
| `CTRL` + `R` | | Enter characters to search for in the history <br> (repeat `CTRL` + `R` to keep going back, <br> `ENTER` to put command in prompt) |
| `CTRL` + `C` | | Abort (kill) current process |
| `CTRL` + `D` | `exit` | Exit the current shell (/ interactive job) |
| `CTRL` + `Z` | (`bg` / `fg`)| Suspend (pause) a process, <br> then use `bg` to move to background|

---

# Keyboard Shortcuts and Tricks II

| Shortcut | Function
|--|--|
| `Ctrl` + `Shift` + `c`  | Copy |
| `Ctrl` + `Shift` + `v`  | Paste |
| `Ctrl` + `a` | Go to beginning of line |
| `Ctrl` + `e` | Go to end of line |
| `Ctrl` + `u` | Cut to beginning of line |
| `Ctrl` + `k` | Cut to end of line |
| `Ctrl` + `w` | Cut previous word |
| `Ctrl` + `y` | Paste previously cut element |
| `Alt` + `.` | Paste last argument of last command |


---
class: center middle inverse
name:script

# Running a Very Minimal Script

----

<br><br><br><br>

### [[Back to overview]](#overview)

---

## A very minimal script

- A script called `hello.sh`:

  ```sh
  #!/bin/bash
  set -e -u -o pipefail

  echo "Hello ${1}!"    # ${1} is standard input!
  ```

--

- Run the script:

  ```sh
  hello.sh Jelmer
  # Hello Jelmer!
  ```

--

- We can also redirect the output to a file:
 
   ```sh
  hello.sh Jelmer > hello.txt
  
  cat hello txt
  # Hello Jelmer!
  ``` 
  
---
class: center middle inverse

# Questions?


