<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>An Introduction to the shell</title>
    <meta charset="utf-8" />
    <meta name="author" content="Jelmer Poelstra" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# An Introduction to the shell
### Jelmer Poelstra
### MCIC Wooster
### 2020/12/16 (updated: 2020-12-04)

---




## What is a shell?

- The shell is a **command-line interface (CLI) to the
  operating system**.

- At least, for Unix-like operating systems,
  such as Linux and Mac.   
  (In Windows, there isn't really a shell, but there are [ways to   get one](#windows-shell)).

--

&lt;br&gt;

### Shell flavors

- Many shell flavors exist but are very similar.

- We will be using **bash shell**.   
  This is most common shell, and the default in Mac and Linux,
  including at OSC (which runs Linux).

---

## But what can I do in the shell?

--

**The shell:**

- Provides a powerful way to **manage and manipulate files**.

--

- Is the most efficient (or only) way to **run many programs
  and submit scripts** -- especially when dealing with bioinformatic data.

--

- Is the most efficient (or only) way to **interact with remote
  computers** such as the OSC clusters.

--

- Makes it easy to **keep *exact* track of what you've done**.

---

## Let's open up a shell at OSC!

OSC allows us to use a shell within the browser at 
&lt;https://ondemand.osc.edu/&gt;.

&lt;br&gt;

&lt;p align = "center"&gt;
&lt;img src=figs_shell/OSC_shell.png width="900"&gt;
&lt;/p&gt;

&lt;br&gt;

- In the "`Clusters`" dropdown, Click "`Pitzer Shell Access`".


---

## Lots of welcome messages

&lt;p align="left"&gt;
&lt;img src=figs_shell/OSC_welcome.png width="600"&gt;
&lt;/p&gt;

&lt;p align="center"&gt;
&lt;img src=figs_shell/OSC_welcome2.png width="900"&gt;
&lt;/p&gt;

--

### And a **prompt** -- this is where we type.

&lt;p align="center"&gt;
&lt;img src=figs_shell/OSC_prompt.png width="900"&gt;
&lt;/p&gt;

---
class: center middle

# Everything you type in the shell &lt;br&gt; is supposed to be a command

--

### Basic usage is just memorizing common commands

---

## A trivial example: the "`cal`" command

- Just typing `cal` prints a calendar to screen:

  ```sh
  $ cal      # I'm using a $ to indicate the prompt
  ```

--

&lt;p align="left"&gt;
&lt;img src=figs_shell/cal.png width="400"&gt;
&lt;/p&gt;

---

## A trivial example: the "`cal`" command

- Just typing `cal` prints a calendar to screen:

  ```sh
  $ cal      # I'm using a $ to indicate the prompt
  ```

- We can use the "-j" or "-m" **options** (flags):
  ```sh
  $ cal -j    # Show a Julian calendar
  $ cal -m    # Have weeks start on Monday
  ```

--

- We can use a year as an **argument** (parameter):
  
  ```sh
  $ cal 2020  # Print the calendar for 2020
  ```

--

- We can combine options and arguments, e.g.:

  ```sh
  $ cal -j -m 2020
  
  $ cal -jm 2020     # Shorter notation!
  ```

---
class: middle center inverse

# `cal` 
-----

# THE DEMO


---

## Recap ;)

- We can use **options (flags) and arguments (parameters)** &lt;br&gt; to
  modify or determine what a command does.

- These arguments and options are **separated by spaces**.

- Note that everything after a "`#`" is ignored -- useful for comments!

--

&lt;br&gt;

### What if my argument, e.g. a file name, has a space in it?

--

**Quote it!**


```sh
$ echo "Hello World"
# Hello World

$ mv "My bad file name.docx" "My_better_file_name.docx"
```

**And avoid spaces in file names...**

---

## How can we know a command's options?

Many commands have a "`--help`" option:

```sh
cal --help
# Usage:
#  cal [options] [[[day] month] year]

# Options:
#  -1, --one        show only current month (default)
#  -3, --three      show previous, current and next month
#  -s, --sunday     Sunday as first day of week
#  -m, --monday     Monday as first day of week
#  -j, --julian     output Julian dates
#  -y, --year       show whole current year
#  -V, --version    display version information and exit
#  -h, --help       display this help text and exit
```

---

## How can we know a command's options? (Cont.)

- Using the `man` ("manual") command,   
  whose argument is the command or utility we want the manual for:

```sh
$ man ls
```
&lt;p align="center"&gt;
&lt;img src=figs_shell/man_ls.png width="600"&gt;
&lt;/p&gt;


---
class: center middle inverse

## Let's learn some useful commands, maybe

&lt;br&gt;&lt;br&gt;

---
class: center middle inverse

# Part A: &lt;br&gt;&lt;br&gt; Navigation

---

## Navigation: overview

```sh
$ pwd   # Provide Working Directory (where am I?)

$ ls    # List files and dirs in your current working directory

$ cd    # Change working directory
```

--

&lt;br&gt;

- Which of these commands might need an *argument*?

--

```sh
$ cd &lt;destination-dir&gt;
```

---

## Navigation I: **`pwd`** (Provide Working Directory)

```sh
$ pwd
# /users/PAS0471/jelmer/CSB
```

--

&lt;br&gt;

- Notice that directories are separated by **forward slashes "`/`"** &lt;br&gt; in Unix environments.

&lt;br&gt;

- When moving files around, it is useful to know the following shortcut
  for the current working directory:

  ```sh
  .
  ```


---

## Navigation II: `ls` (LiSt)

```sh
$ ls

# data_wrangling git good_code LICENSE README.md
```

--

&lt;br&gt;

- We can try some options to modify the output:

```sh
$ ls -l -h   # -l: long format / -h: human-readable file sizes

# drwxr-xr-x 7 jelmer PAS0471 4.0K Dec  4 11:23 data_wrangling
# drwxr-xr-x 5 jelmer PAS0471 4.0K Dec  4 11:23 git
# drwxr-xr-x 5 jelmer PAS0471 4.0K Dec  4 11:23 good_code
# -rw-r--r-- 1 jelmer PAS0471  35K Dec  4 11:23 LICENSE
# -rw-r--r-- 1 jelmer PAS0471 2.4K Dec  4 11:23 README.md
```

--

- Again, these options can be "pasted together":

```sh
ls -lha     # We've added the "-a" option to show hidden files
```

---

## Navigation III: cd (Change Directory)

- Using a **relative path** (i.e., not starting from the root dir):
```sh
cd data_wrangling/
```

- Using an **absolute path** (i.e., starting from the root dir):
```sh
cd /users/PAS0471/jelmer/CSB/data_wrangling
```

--

### Tricks!

```sh
cd ..     # Move one directory up
cd ../..  # Move two directories up
cd ~      # Move to your home dir (~ is always /home/&lt;user&gt;/ !)
cd -      # Go back to last visited dir (like "Back" in a browser)

cd .      # What does this do?
```

---
class: center middle inverse

# Part B : &lt;br&gt;&lt;br&gt; Managing files

---

## Managing files: overview

```sh
$ mkdir &lt;dirname&gt; # Make a new directory
$ cp &lt;from&gt; &lt;to&gt;  # Copy files or dirs
$ mv &lt;from&gt; &lt;to&gt;  # Move files or dirs (also functions as rename!)
$ rm &lt;file&gt;       # Remove a file or directory
```

--

&lt;br&gt;

### Operating on directories:

- For `cp` and `rm`,   
  the "`-r`" option is needed to act on directories
  (and their contents!)

```sh
# Copy "unix/data/" to the current dir (recall the "." shortcut) 
cp -r unix/data . 
  
# Remove "my_dir" and its contents.
# Beware: there is NO THRASH BIN in the shell!
rm -r my_dir/
```


---

## Your turn

1. Go to **XXX**

1. Create a new directory with your name (no spaces!)

1. Copy README.md into the directory

1. Move into your directory

1. Rename README.md to README.txt

1. Remove your namesake directory and all its contents

---

## Solution

```sh
mkdir jelmer_poelstra

cp README.md jelmer_poelstra/ # Trailing slash can be omitted

cd jelmer_poelstra/           # Idem

mv README.md README.txt

cd ..

rm -r jelmer_poelstra         # Non-interactive: "rm -rf"
```

---

## Managing files: Wildcards

|Wildcard | Matches |
|-|-|
| * | Any number of any character, including nothing |
| ? | Any single character 
| [] | One of the "character set" within the brackets   
| [^] | None of the "character set" within the brackets   

---
class: center middle inverse

# Part C :&lt;br&gt;&lt;br&gt;Working with text files

---

## Text files: Overview

.pull-left[
### `less`
A file "pager".

&lt;br&gt;

### `cat`
Print contents of (a) file(s).   
Short for conCATenate.
]

.pull-right[
### `head` / `tail`
Show the first or last lines of a file.

&lt;br&gt;

### `grep`
Search for contents within files.
]

---

## Text files I: `less`

- `less` does not load entire files into memory,   
  **so you can easily look at enormous files.**

  ```sh
  less myfile.txt
  ```

- Now you'll be inside the pager, and your prompt is gone.

--

&lt;br&gt;

- Leave `less` by pressing "&lt;kbd&gt;q&lt;/kbd&gt;"

- Many keyboard shortcuts to navigate:
  - `d` / `u` &amp;nbsp; &amp;nbsp; go down / up half a page
  - `g` / `G` &amp;nbsp; &amp;nbsp; go to the first / last line
  - `/` &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; then type keyword to search for
  - `n` / `N` &amp;nbsp; &amp;nbsp; go to next/previous search match

--

### Less try it!

---

## Text files II: `cat`

- `cat` will print one or more files to screen.   
  
  ```sh
  cat my_file.txt
  
  cat my_file.txt &gt; new_file.txt    # What did we do here?
  ```

--

&lt;br&gt;

- If you have, say, 10,000 `fasta` files in a directory,
  each representing a gene, and you want to put them all into
  a single `fasta` file:
  
  ```sh
  cat *.fasta &gt; all.fasta # Wow!
  ```
  Here, the **`*`** allowed us to match all files ending in ".fasta".

--

&lt;br&gt;

- `z` counterparts of these functions directly show zipped files:

  ```sh
  zcat my_fastq.gz
  ```

---

## Text files II: `head` and `tail`

- `head` / `tail` will simply show the first / last few lines of a file.

```sh
head my_file.txt        # By default, shows the first 6 lines
head -n 1 my_file.txt   # Just show the first line
```

--

```sh
tail my_file.txt       # By default, shows the first 6 lines
tail -n 1 my_file.txt  # Just show the last line
```

- Showing the last line of a 100 GB file outside of the
  shell would be quite an ordeal, while in the shell it's
  extremely simple and lightning fast.

---

## Text files II: `head` and `tail` (cont.)

### More useful options:

- Skip the first line of a file:

  ```sh
  tail -n +2 file
  ```

&lt;br&gt;

- Skip the last line of a file:
  
  ```sh
  head -n -1 file
  ```

--

&lt;br&gt;

- Print line number 1866:
  
  ```sh
  head -n 1866 file | tail -n 1   # We'll talk about the "|" more
  ```

---

## Text files IV: `grep`

---

## Some other commands worth mentioning:

- `cut`
- `wc` / `wc -l`
- `sort`

---
class: center middle inverse

# Part D :&lt;br&gt;&lt;br&gt;Redirection and pipes

---

## Redirection

- STDOUT

```sh
[COMMAND] &gt; filename
[COMMAND] &gt;&gt; filename

[COMMAND] &lt; filename
# Cf [COMMAND] filename
```

---

## Pipes and STDIN

---
class: center middle inverse

# Part E :&lt;br&gt;&lt;br&gt;Keyboard shortcuts and general tricks

---

- CTRL+C
- CTRL+D / exit
- CTRL+L / clear

- Tab completion
- Up arrow
- CTRL+R to search history


---

---
class: center middle inverse

# Part F :&lt;br&gt;&lt;br&gt;Submitting jobs (scripts) &lt;br&gt; to the SLURM scheduler 

---

## Interactive jobs on `SLURM`

- Start a 1-hour, single-core interactive job with a `bash` shell:
```sh
$ srun --nodes=1 --ntasks-per-node=1 --time=01:00:00 --pty bash -i
```

- Can also use `salloc` and `sinteractive`.

---

## Batch jobs on `SLURM`

- To submit a job:
```sh
$ sbatch myscript.sh [script-options] [script-args]
```

- To monitor your jobs:
```bash
$ squeue -u &lt;username&gt;
```

--

&lt;br&gt;

### Okay, but what's inside the script?

---

## Inside the script

### Start with a *shebang* line

A job script needs to start with a "*shebang*" line,
which points the computer to the program to be used:
```sh
#!/bin/bash
```

### Then, provide options to `sbatch`. Some common ones:

```sh
#SBATCH --nodes=&lt;N&gt;
#SBATCH --ntasks-per-node=&lt;N&gt;
#SBATCH --time=HH:MM:SS
#SBATCH --mem=Xgb
#SBATCH --job-name=&lt;myjobname&gt;
#SBATCH --account=&lt;projectID&gt;
```

---

## A very minimal example

- A script called `hello.sh`:

```sh
#!/bin/bash
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=1
#SBATCH --time=01:00:00

echo "Hello $1"    # $1 is standard input!
```
--

&lt;br&gt;

- We can submit it to the queue using:

```sh
sbatch hello.sh Jelmer
# Submitted batch job 2451088
```

---

## A very minimal example (cont.)

- We can check what's happening:

  ```sh
  # JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON) 
  # 2451088 serial-40 hello.sh   jelmer PD       0:00      1 (None) 
  ```

--

- And again a little later:

  ```sh
  # JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON) 
  ```

--

- Do we have output?

  ```sh
  ls slurm*
  # slurm-2451088.out
  ```

--

- Let's check it out:

  ```sh
  cat slurm-2451088.out
  # Hello Jelmer
  ```

---
class: center middle inverse

# Questions?


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
