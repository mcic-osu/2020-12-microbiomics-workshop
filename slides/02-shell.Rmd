---
title: "An Introduction to the shell"
author: "Jelmer Poelstra"
institute: "MCIC Wooster"
date: "2020/12/16 (updated: `r Sys.Date()`)"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---
class:inverse middle center

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
```
# Overview

.pull-left[
### [Introduction](#intro)
### [Navigation](#navigation)
### [Standard in/out and Pipes](#stdin)
### [Managing Files](#managing_files)
]

---
class:inverse middle center
name: overview

# Overview

.pull-left[
### [Introduction](#intro)
### [Navigation](#navigation)
### [Standard in/out and Pipes](#stdin)
### [Managing Files](#managing_files)
]

.pull-right[

### [Wildcards](#wildcards)
### [Working with Text Files](#text_files)
### [A Very Minimal Script](#script)
### [Bonus Material](#bonus)
]



---
class:inverse middle center
name:intro

# Introduction

-----

<br><br><br><br>

### [[Back to overview]](#overview)

---

## What is a shell?

- The shell is a **command-line interface (CLI) to the
  operating system**.

- That is, for Unix-like operating systems,
  such as Linux and Mac.   
  (In Windows, there isn't really a shell, but there are [ways to   get one](#windows-shell)).

--

<br>

### Shell flavors

- Many shell variants exist but are very similar.

- We will be using the **bash shell**.   
  
  This is most common shell, and the default in Mac and Linux,
  including at OSC (which runs Linux).

---

## But what can I do in the shell?

--

**The shell:**

- Provides a powerful way to **manage and manipulate files**.

--

- Is the most efficient (or only) way to **run many programs
  and submit scripts** -- especially when dealing with bioinformatic data.

--

- Is the most efficient (or only) way to **interact with remote
  computers** such as the OSC clusters.

--

- Makes it easy to **keep *exact* track of what you've done**.

---

## Let's open up a shell at OSC!

- The Ohio Supercomputer Center (OSC) allows us to use a shell   
  *within* a browser at <https://ondemand.osc.edu/>.

<br>

<p align = "center">
<img src=figs_shell/OSC_shell.png width="900">
</p>

<br>

- In the "`Clusters`" dropdown menu, click "`Pitzer Shell Access`".


---

## The shell prompt

- OSC show us lots of welcome messages and information:

<p align="left">
<img src=figs_shell/OSC_welcome.png width="550">
</p>

<p align="center">
<img src=figs_shell/OSC_welcome2.png width="1000">
</p>

--

- And a **prompt** -- this is where we type.

<p align="center">
<img src=figs_shell/OSC_prompt.png width="900">
</p>

---
class: center middle

# In the shell, <br> we're mostly typing commands

### Basic usage is just memorizing commands for common utilities


---

## A first example: the "`cal`" command

- Just typing `cal` prints a calendar to screen:

  ```sh
  $ cal      # I'm using a $ to indicate the prompt.
               # Everything after a "#" is ignored.
  ```

--

<p align="left">
<img src=figs_shell/cal.png width="400">
</p>

---

## A first example: the "`cal`" command

- Just typing `cal` prints a calendar to screen:

  ```sh
  $ cal      # I'm using a $ to indicate the prompt.
               # Everything after a "#" is ignored.
  ```

- We can use the "-j" or "-m" **options** (flags):
  ```sh
  $ cal -j    # Show a Julian calendar
  $ cal -m    # Have weeks start on Monday
  ```

--

- We can use a year as an **argument** (parameter):
  
  ```sh
  $ cal 2020  # Print the calendar for 2020
  ```

--

- We can combine options and arguments, e.g.:

  ```sh
  $ cal -j -m 2020
  
  $ cal -jm 2020     # Shorter notation!
  ```

---

## What we've learned from `cal`

- After typing a command, we issue it using `Enter`, the result will
  be printed to screen, and we get our prompt back.
  
- We can use **options (flags) and arguments (parameters)** <br> to
  modify or determine what a command does.

- These arguments and options are **separated by spaces**.

--

<br>

- Note that everything after a **"`#`"** is ignored -- useful for comments!

---

## How can we know a command's options?

Many commands have a **"`--help`"** option:

```sh
$ cal --help
# Usage:
#  cal [options] [[[day] month] year]

# Options:
#  -1, --one        show only current month (default)
#  -3, --three      show previous, current and next month
#  -s, --sunday     Sunday as first day of week
#  -m, --monday     Monday as first day of week
#  -j, --julian     output Julian dates
#  -y, --year       show whole current year
#  -V, --version    display version information and exit
#  -h, --help       display this help text and exit
```

---

## How can we know a command's options? (cont.)

- Using the **`man`** ("manual") command,   
  whose argument is the command or utility we want the manual for:

```sh
$ man ls
```
<p align="center">
<img src=figs_shell/man_ls.png width="600">
</p>


---
class: center middle

# Let's learn some useful commands...

<br><br>




---
class: center middle inverse
name:navigation

# Navigation

----

<br><br><br><br>

### [[Back to overview]](#overview)

---

## Commands for navigation: Overview

.pull-left[
### `pwd`
Print the Working Directory

<br>

### `cd`
Change (working) Directory
]

.pull-right[
### `ls`
LiSt files and directories
]

---

## Commands for navigation: Overview

```sh
$ pwd   # Print Working Directory (where am I?)

$ cd    # Change working directory

$ ls    # List files and dirs in your current working directory
```

<br>

- Which of these commands might need an *argument*?

--

```sh
$ cd <destination-dir>
```

---

## Navigation: `pwd`

To let the shell tell you what your working directory is, <br> use **`pwd`** (Print Working Directory):

  ```sh
  $ pwd
  # /users/PAS0471/jelmer/
  ```

--

<br>

- Notice that directories are separated by **forward slashes "`/`"** <br> in Unix environments.

<br>

---

## Navigation: `cd`

To change working directory, use **`cd`** (Change Directory)

- Using a **relative path** (i.e., not starting from the root dir):
```sh
$ cd workshops/2020-12_micro/
```

- Using an **absolute path** (i.e., starting from the root dir):
  ```{sh, eval=FALSE}
  $ cd /fs/project/PAS0471/workshops/2020-12_micro/
  ```

--

<br>

- **Note that the shell did not give us any feedback!** (This is normal.)

  Check whether it worked:
  ```sh
  $ pwd
  # /fs/project/PAS0471/workshops/2020-12_micro/
  ```

---

## Navigation: `cd` (cont.)

### Tricks!

```sh
$ cd ..     # Move one directory up
$ cd ../..  # Move two directories up
$ cd ~      # Move to your home dir (~ is always /home/<user>/ !)
$ cd -      # Go back to last visited dir (like "Back" in a browser)

$ cd .      # This doesn't move you anywhere, as `.` is a shortcut
            # for the current working directory (useful elsewhere)
```

---

## Navigation: `ls`

#### To list the contents of our current working directory, use **`ls`** (LiSt)

```sh
$ ls
# TODO: OUTPUT
```

--

<br>

- We can try some options to modify the output:

  ```sh
  $ ls -l -h   # -l: long format / -h: human-readable file sizes
  # TODO: OUTPUT 
  ```

--

- Again, these options can be "pasted together":

  ```sh
  $ ls -lha     # Also added the "-a" option to show hidden files
  ```

---

## Navigation: `ls` (cont.)

- We can also provide a directory or file name as an argument:

  ```sh
  $ ls -lh Experiment description
  ```
  
---

## Navigation: `ls` (cont.)

- We can also provide a directory or file name as an argument:

  ```sh
  $ ls -lh Experiment description
  # ls: cannot access Experiment: No such file or directory
  # ls: cannot access description: No such file or directory
  ```

  What just happened? And how do we get around this?

<br>

--

- **To interpret spaces literally**, quote the full string or "escape" the space:

  ```sh
  $ ls "Experiment description"
  
  $ ls Experiment\ description
  ```

--

<br>

- **But, better to avoid spaces in file names!**



---
class: center middle inverse
name:stdin

# Standard input/output and Pipes

----

<br><br><br><br>

### [[Back to overview]](#overview)

---

## Standard output and redirection

- The regular output of a command is called **"standard out"** ("*stdout*").   
  By default, this is printed to screen,
  but it can be **redirected to a file**.

--

- When redirecting output to a file with `>`:
  - Will create file if it doesn't exist.
  - Will **overwrite** any contents if the file does exist. 

  ```sh
  $ ls -lhr project_A > lift_of_files.txt
  ```

--

- **Append** the output to a file with `>>`:

  ```sh
  $ ls -lhr project_B >> lift_of_files.txt
  ```

--

<br>

- See the [bonus materials](#stderr) to learn about redirecting **error** messages.


---

## Standard input and pipes

- A file name can be given as an argument to most commands.   
  If a file name is provided, this file will be read and
  represent the *input* upon which the command will act:

  ```sh
  $ grep "missing_file" lift_of_files.txt
  ```

--

<br>

- Most command *also* accept input from "standard input" (*stdin*),   
  using the pipe:

  ```sh
  $ cat lift_of_files.txt | grep "missing_file"
  ```
  
  The pipe `|` presents the output (*stdout*) of `cat` as
  input (*stdin*) to `grep`.
  

---
class: center middle inverse
name:managing_files

# Managing Files

----

<br><br><br><br>

### [[Back to overview]](#overview)

---

## Commands to manage files: Overview

.pull-left[
### `mkdir`
Make a new directory.

<br>

### `rm`
Remove files (and directories).
]

--

.pull-right[
### `cp`
Copy files (and directories).

<br>
### `mv`
Move or rename files and directories.
]

---

## Commands to manage files

```sh
$ mkdir <dirname> # Make a new directory
$ rm <file>       # Remove files (and/or directories)
                  # BEWARE: There is no Thrash Bin in the shell!
$ cp <from> <to>  # Copy files (and/or directories)
$ mv <from> <to>  # Move or rename files and/or directories
```

<br>

--

- Examples:
  
  ```sh
  mkdir metadata
  mkdir -p manuscript/fig/supp/      # `-p`: multiple levels
  ```
  
--
  
  ```sh
  mv "Experiment description" experiment_description
  ```
  
  ```sh
  cp results/fig/Fig1.png .          # `.` for current wd            
  ```
  
---

## Commands to manage files (cont.)

```sh
$ mkdir <dirname> # Make a new directory
$ rm <file>       # Remove files (and/or directories)
                  # BEWARE: There is no Thrash Bin in the shell!
$ cp <from> <to>  # Copy files (and/or directories)
$ mv <from> <to>  # Move or rename files and/or directories
```

<br>

- For `cp` and `rm`, use **"`-r`"** (for "recursive") to act on directories and their contents:

--

  ```sh
  cp -r my_project/ /home/jelmer/backup/ 
    
  rm -r my_project/      # Confirm removal for each file
  rm -rf my_project/     # `-f` for force, no prompting
  ```

--

- The `-r` option is not needed with `mv`.

---
background-color:#e4ede4

## Your turn: Navigation & Managing files

1. Go to `/fs/project/PAS0471/workshops/2020-12_micro/`.   
   **This is our workshop's home directory.**

2. Create a new directory with your name (no spaces!) *within* the users/ directory.

3. Copy `/fs/project/PAS0471/workshops/2020-12_micro/README.txt` into your directory.

4. Move into your directory.

5. Rename `README.txt` to `README.md`.

6. Move back to our workshop's home directory;
   try to avoid using the full (absolute) path notation to do so.


---
background-color:#e4ede4

## Solutions: Navigation & Managing files

```sh
# 1. Go to `/fs/project/PAS0471/workshops/2020-12_micro/`.
cd /fs/project/PAS0471/workshops/2020-12_micro/

# 2. Create a new dir with your name *within* the users/ directory.
mkdir users/jelmer

# 3. Copy `README.txt` into your directory:
cp README.txt users/jelmer/ # Trailing slash can be omitted

# 4. Move into your directory:
cd users/jelmer/           # Idem

# 5. Rename `README.txt` to `README.md`:
mv README.txt README.md

# 6. Move back to `/fs/project/PAS0471/workshops/2020-12_micro/`:
cd ../..                   # Or: "cd -"

```

---
class:inverse middle center
name:wildcards

# Wildcards

----

<br><br><br><br>

### [[Back to overview]](#overview)

---

## Matching file names with wildcards

|Wildcard | Matches |
|-|-|
| * | Any number of any character, including nothing |
| ? | Any single character 
| [] and [^] | One or none (`^`) of the "character set" within the brackets   

--

- Say we have the following files in a directory:
  ```sh
  # sample1_F.fastq.gz sample1_R.fastq.gz
  # sample2_F.fastq.gz sample2_R.fastq.gz
  # sample3_F.fastq.gz sample3_R.fastq.gz
  ```

--

<br>

- **To match both "sample1" files:**

  ```sh
  ls sample1_?.fastq.gz
  ls sample1*
  ls sample1*fastq.gz
  ```

---

## Matching file names with wildcards (cont.)

|Wildcard | Matches |
|-|-|
| * | Any number of any character, including nothing |
| ? | Any single character 
| [] and [^] | One or none (`^`) of the "character set" within the brackets   

- Say we have the following files in a directory:
  ```sh
  # sample1_F.fastq.gz sample1_R.fastq.gz
  # sample2_F.fastq.gz sample2_R.fastq.gz
  # sample3_F.fastq.gz sample3_R.fastq.gz
  ```

<br>

- **To match only files with forward ("F) reads:**
  
  ```sh
  $ ls *F*
  $ ls *F.fastq.gz
  ```

---

## Matching file names with wildcards (cont.)

|Wildcard | Matches |
|-|-|
| * | Any number of any character, including nothing |
| ? | Any single character 
| [] and [^] | One or none (`^`) of the "character set" within the brackets   

- Say we have the following files in a directory:
  ```sh
  # sample1_F.fastq.gz sample1_R.fastq.gz
  # sample2_F.fastq.gz sample2_R.fastq.gz
  # sample3_F.fastq.gz sample3_R.fastq.gz
  ```

<br>

- When using a "character set", the presence of *any* of the characters will
  trigger a match. **To match files for sample1 and sample2 only:**
  
  ```sh
  $ ls sample[12]*   # Use the character class notation
  $ ls sample[1-2]*  # Can use ranges like [0-9], [A-Z], [a-z].
  $ ls sample[^3]*   # Other way around: exclude sample3
  ```

---
background-color:#e4ede4

## Your turn: Wildcards

---
background-color:#e4ede4

## Solutions: Wildcards

---
class: center middle inverse
name:text_files

# Working With Text Files

----

<br><br><br><br>

### [[Back to overview]](#overview)


---

## Commands to work with text files: Overview

.pull-left[
### `cat`
Print contents of (a) file(s).   

<br>

### `head` / `tail`
Show the first or last lines of a file.
]

.pull-right[
### `grep`
Search for contents within files.

<br>

### (In bonus materials: [`less`](#less))
]

---

## Text files: `cat`

- `cat` will print one or more files to screen.   
  
  ```sh
  $ cat my_file.txt
  
  $ cat my_file.txt > new_file.txt  # What did we do here?
  ```

--

- If you have, say, 10,000 `fasta` files in a directory,
  each representing a gene, and you want to put them all into
  a single `fasta` file:
  
  ```sh
  $ cat *.fasta > all.fasta        # Recall the `*` wildcard  
  ```

--

<br>

### Nice viewing of tabular files: `column -t`

  ```sh
  column -t mytable.txt
  ```


---

## Text files: `head` and `tail`

- `head` / `tail` will simply show the first / last few lines of a file.

  ```sh
  $ head my_file.txt        # Default: shows first/last 6 lines
  
  $ tail -n 1 my_file.txt   # Just show the last/first line
  ```

- Showing the last line of a 100 GB file outside of the
  shell would be quite an ordeal, while in the shell it's
  extremely simple and lightning fast!

--

<br>

- Skip the first line of a file:

  ```sh
  $ tail -n +2 file
  ```

--

- Print line number 1866:
  
  ```sh
  $ head -n 1866 file | tail -n 1
  ```

---

## Text files: `grep`

`grep` searches for strings
(or regular expression patterns) in files.   
By default, it returns lines for which matches were found.

- Create a file for all annotations for "Gene001":
  ```sh
  grep "Gene001" my.gff > Gene001.gff
  ```

--

- Count the number of lines containing "exon": 
  ```sh
  grep -c "exon" my.gff   # -c: count matches
  ```

--

- Remove the header lines, which start with a `#`, from a VCF file:
  ```sh  
  grep -v "^#" my.vcf     # -v: reverse search  
  ```

--

Many options, e.g.:
  - `-r` to search recursively (search all your files for a certain word)
  - `-n` to print line numbers along with matches
  

---
background-color:#e4ede4

## Your turn: Working with text files

**Now, we'll look at a file with some metadata for our samples.**

1. Move into the `metadata` folder within our workshop's home directory (`/fs/project/PAS0471/workshops/2020-12_micro/`).

1. Print the entire file to screen with `cat` and with `column -t`.
   Compare the output, especially in the first lines of the file.

2. Print the first 6 lines of the file, then make them line up with
  `column -t`.

2. Print everything but the first line, which has the column headers.

3. Print the line for sample "304-S1".

---
background-color:#e4ede4

## Solutions: Working with text files

1. Move into the `metadata` folder:
  
    ```sh
  mv metadata/
  ```

1. Print the entire file to screen with `cat` and with `column -t`:
  
  ```sh
  cat V4_meta.txt
  column -t V4_meta.txt
  ```
  
2. Print the first 6 lines of the file, then make them line up with
  `column -t`:
  
  ```sh
  head V4_meta.txt | column -t
  ```
  
2. Print everything but the first line, which has the column headers:
  
  ```sh
  tail -n +2
  ```

3. Print the line for sample "304-S1":
    
  ```sh
  grep "304-S1" V4_meta.txt
  ```



---
class: center middle inverse
name:script

# Running a Very Minimal Script

----

<br><br><br><br>

### [[Back to overview]](#overview)

---

## Running a very minimal script

### TODO: Change to fastqc?

- A script called `hello.sh`:

  ```sh
  #!/bin/bash
  set -e -u -o pipefail

  echo "Hello ${1}!"    # ${1} is standard input!
  ```

--

- Run the script:

  ```sh
  $ hello.sh Jelmer
  # Hello Jelmer!
  ```

--

- We can also redirect the output to a file:
 
   ```sh
  $ hello.sh Jelmer > hello.txt
  
  $ cat hello txt
  # Hello Jelmer!
  ``` 
  
---
class: center middle inverse

# Questions?


---
class: inverse center middle
name:bonus

# Bonus Materials

-----

### I: [Keyboard Shortcuts and General Tricks](#tricks)
### II: [Text File Data Tools](#datatools)
### III: [The `less` Pager](#less)
### IV: [Standard Error](#stderr)

<br><br>

### [[Back to overview]](#overview)

---
class: center middle inverse
name:tricks

# Bonus Material I:
# Keyboard Shortcuts and General Tricks

----

<br><br><br><br>

### [[Back to overview]](#overview)

---

# Keyboard Shortcuts and Tricks I

| Shortcut | Command | Function
|--|--|
| `Tab` | | Tab completion! Files, commands, etc. <br> Double `Tab` to show options when <br> multiple are still available.|
| Up/Down arrow | | Cycle through command history|
| `CTRL` + `R` | | Enter characters to search for in the history <br> (repeat `CTRL` + `R` to keep going back, <br> `ENTER` to put command in prompt) |
| `CTRL` + `C` | | Abort (kill) current process |
| `CTRL` + `D` | `exit` | Exit the current shell (/ interactive job) |
| `CTRL` + `Z` | (`bg` / `fg`)| Suspend (pause) a process, <br> then use `bg` to move to background|

---

# Keyboard Shortcuts and Tricks II

| Shortcut | Function
|--|--|
| `Ctrl` + `Shift` + `c`  | Copy |
| `Ctrl` + `Shift` + `v`  | Paste |
| `Ctrl` + `a` | Go to beginning of line |
| `Ctrl` + `e` | Go to end of line |
| `Ctrl` + `u` | Cut to beginning of line |
| `Ctrl` + `k` | Cut to end of line |
| `Ctrl` + `w` | Cut previous word |
| `Ctrl` + `y` | Paste previously cut element |
| `Alt` + `.` | Paste last argument of last command |

---

# Keyboard Shortcuts and Tricks III:<br>The OSC browser shell

- No right-mouse click options

- Double-clicking text will copy it to the clipboard

- `Ctrl` + `v` will paste (no `Shift` needed)

- `Ctrl` + `w` (cut last word) does not work --   
  reserved browser shortcut to close a tab.

---

## Brace expansion

```sh
$ touch sample{1,2,3}_{F,R}.fastq.gz

$ ls
#sample1_F.fastq.gz  sample1_R.fastq.gz  sample2_F.fastq.gz  sample2_R.fastq.gz  sample3_F.fastq.gz  sample3_R.fastq.gz
```

---
class: center middle inverse
name: datatools

# Bonus Material II:
# Text File Data Tools

----

<br><br><br><br>

### [[Back to overview]](#overview)

---

## Text file data tools

- **`cut`**: cut (select) one or more columns from a tabular file
  
  ```sh
  $ cut -f 2-5 < my.gff   # Cut the 2nd through 5th column 
  ```

- **`wc` / `wc -l`**: count words / lines.
  
  ```sh
  $ wc -l my.fastq   # Count the number of lines in a fastq file.
  ```

--

<br>

- **`sort`**: sort a file by a specified column
  
  ```sh
  $ sort -k5,5 my.bed
  ```
  
- **`uniq` / `uniq -c`**: retain / count unique occurrences (*if in order!*)

  ```sh
  $ uniq -c list_of_names.txt # Would return count for each name
  ```

---

## Combining these tools can be very powerful!

For instance, the "pipeline" below will return a sorted list (most commmon
to least common) of annotation types from an annotation file<sup>[1]</sup>:

```sh
$ grep -v "^#" my.gff | cut -f3 | sort | uniq -c | sort -rn
# 36128 exon
# 25901 CDS
# 7588 UTR
# ...
```

--

- Command-by-command (note **`\`** to continue across lines):

  ```sh
  $ grep -v "^#" my.gff | \ # Excl. header lines starting with `#`
  +   cut -f3 | \           # Select only the 3rd column
  +   sort | \              # Sort alphabetically
  +   uniq -c | \           # Count each unique element
  +   sort -rn              # Numerically reverse-sort
  ```


.footnote[<sup>[1]</sup>From: Bioinformatics Data Skills (Buffalo 2015)]


---
background-color:#e4ede4

## Your Turn: Advanced exercises

1. How many samples (lines) do we have for each "Experiment"?

2. How many different "Blocks" do we have?   
   Hint: Make sure to exclude the lines which have "NA" in the "Blocks" column.

3. Earlier, with `less`, we looked for the pattern *"GAGTGCCAGCCGCCGCGGTAATACGTAGGGTGCGAGCGTTAATCGGAATTACTGGGC"*    
  in the file `data/fastq/502-S4-V4-V5_S66_L001_R1_001.fastq.gz`.
  
  Now, count how many times this pattern occurs in the file using `grep`.


---
background-color:#e4ede4

## Solutions: Advanced exercises

1. How many samples (lines) do we have for each "Experiment"?
  
  ```sh
  tail -n +2 V4_meta.txt | cut -f 3 | sort | uniq -c
  ```

2. How many different "Blocks" do we have?

  ```sh
  $ tail -n +2 V4_meta.txt | grep -v "NA" | \
  +    cut -f 6 | sort | uniq | wc -l
  ```

3. Count occurences of
  *"GAGTGCCAGCCGCCGCGGTAATACGTAGGGTGCGAGCGTTAATCGGAATTACTGGGC"*
  in the file `data/fastq/502-S4-V4-V5_S66_L001_R1_001.fastq.gz`.

  ```sh
  $ grep -c "GAGTGCCAGCCGCCGCGGTAATACGTAGGGTGCGAGCGTTAATCGGAATTACTGGGC" \
  +      data/fastq/502-S4-V4-V5_S66_L001_R1_001.fastq.gz
  ```


---
class: center middle inverse
name:less

# Bonus Material III:
# The `less` Pager

----

<br><br><br><br>

### [[Back to overview]](#overview)

---

## The `less` pager

- `less` doesn't load entire files into memory: **easy to look at large files**.

  ```sh
  $ less my_file.txt
  
  $ zless my_fastq.gz    # `zless` variant to view zipped files!
  ```

- Now you'll be inside the pager, and your prompt is gone.

--

- Keyboard shortcuts:

| key | function |
|--|--|
| `q` | Exit `less` | 
| `d` / `u` | Go down / up half a page. <br>Note: arrow keys and `pgup` / `pgdn` usually also work.|
| `g` / `G` | Go to the first / last line (`home` / `end` also work)
|`/` | Search: next type keyword to search for
| `n` / `N` | Go to next/previous search match

---
background-color:#e4ede4

## Your turn: `less`

You should still be in our workshop's home directory (`/fs/project/PAS0471/workshops/2020-12_micro/`).

This directory contains the data we will be working with today and tomorrow.
In `data/fastq`, you can find the raw gzipped fastq files.

- Open a gzipped fastq file with `less`:
  
  ```{sh, eval=FALSE}
  zless data/fastq/502-S4-V4-V5_S66_L001_R1_001.fastq.gz
  ```

- Try to move around a bit.

- Jump to the first and last line.

- Now look for the following pattern:
  "GAGTGCCAGCCGCCGCGGTAATACGTAGGGTGCGAGCGTTAATCGGAATTACTGGGC"

- Exit.

---
class: center middle inverse
name:stderr

# Bonus Material IV:
# Standard Error

----

<br><br><br><br>

### [[Back to overview]](#overview)

---

## Standard error

- When commands run into errors, they will print error messages.  
  
  Error messages are **not** part of standard out,   
  and instead represent a separate output stream: **"standard error"**.

--

- We can see this when we try to list a non-existing directory:

  ```sh
  ls -lhr solutions/ > solution_files.txt 
  # ls: cannot access solutions.txt: No such file or directory
  ```

- The error was printed to screen. What about the file?

--

  ```sh
  $ ls
  # solution_files.txt
  $ cat solution_files.txt
  $                # We just get our prompt back - file is empty
  ```

--

- To redirect the standard error:

  ```sh
  ls -lhr solutions/ > solution_files.txt 2> errors.txt
  ls -lhr solutions/ &> out.txt # `&>`: combine stdout and stderr
  ```

